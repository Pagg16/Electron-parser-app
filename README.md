# Electron Ozon Parser

Десктопное приложение на Electron для парсинга карточек товаров и отзывов с Ozon.
Проект экспериментирует с подходами к устойчивому парсингу страниц, которые часто меняют верстку и CSS-классы.

## Общая идея

Основная проблема классических парсеров — жесткая привязка к CSS-селекторам. При любом изменении верстки такие решения требуют ручного обновления.

В этом проекте реализована многоуровневая система поиска элементов, где CSS — лишь один из возможных источников данных. При сбоях система пытается восстановиться за счет альтернативных стратегий и сохраняет результаты для последующих запусков.

## Архитектура парсинга

### Самообновляемые базовые классы

При наличии эталонной страницы система может автоматически определить CSS-классы ключевых элементов и сохранить их для повторного использования.

```json
// baseClass/baseClassComment.json
{
  "commetnDate": ".a1b2c3d4",
  "commetnName": ".e5f6g7h8",
  "commentStarRating": ".i9j0k1l2"
}
```

### Архитектура проекта

```
parser_app/
├── main/ # Главный процесс Electron
│ ├── main.js # Точка входа, создание окон
│ ├── handlers/ # Обработчики IPC
│ │ ├── parsingHandlers.js
│ │ ├── windowHandlers.js
│ │ └── createFileExelHandlers.js
│ └── preload/ # Preload скрипты
│
├── parsing/ # Логика парсинга
│ ├── mainParsing.js # Координатор парсинга
│ ├── createBrowser.js # Создание экземпляра браузера
│ ├── createPage.js # Управление страницами
│ └── contentProcessing/ # Обработка контента
│
├── public/ # Статические ресурсы
│ ├── assets/ # Иконки, изображения
│ └── load/ # Загрузочный экран
│
└── src/ # Рендерер-процесс (Vite + React)
```

Используется как быстрый путь при последующих запусках, но не является единственной точкой отказа.

### Координатно-относительный поиск

Помимо селекторов применяется поиск элементов относительно стабильных якорей на странице (например, кнопок или текстовых блоков).

```javascript
const productPrice = {
  name: "productPrice",
  searchType: { locator: "text=Поделиться" },
  cursorPositionInElem: "center",
  child: {
    positionRelative: { x: -300.09375, y: 74 },
    contentCheck: ["innerText"],
  },
};
```

Алгоритм:

1. Находится устойчивый элемент-якорь
2. Определяется его позиция
3. Выполняется смещение по координатам
4. Проверяется содержимое найденного элемента

Этот подход используется как fallback при нестабильных селекторах.

### Многоуровневая стратегия поиска

Поиск элементов выполняется поэтапно:

1. По сохраненным CSS-классам
2. По текстовым признакам и размерам элементов
3. Через относительные координаты от якоря
4. Полный координатный перебор с логированием и обучением

Переход между уровнями происходит автоматически.

## Логирование и отладка

Проект ориентирован на воспроизводимость ошибок и анализ поведения парсера.

```javascript
await addNewlogsSearchElemCoordinates({
  page,
  elemName: "productPrice",
  position: { x: 500, y: 300 },
  searchType: ["classList", "innerText"],
  screenshot: true,
});
```

Сохраняются:

- структурированные JSON-логи
- скриншоты проблемных состояний
- записи сессий парсинга
- история изменения базовых классов

Это позволяет анализировать, почему именно элемент не был найден.

## Поведение, близкое к пользователю

Для снижения риска блокировок используется эмуляция пользовательских действий:

- плавное движение курсора (кривые Безье)
- случайные задержки
- прокрутка страницы
- обработка cookie-баннеров и pop-up окон

```javascript
async function cursorMovement(page, endX, endY) {
  for (let t = 0; t <= 1; t += 0.01) {
    const { x, y } = bezierCurve(start, end, t);
    await page.mouse.move(x, y);
    await page.waitForTimeout(1);
  }
}
```

## Работа с антибот-защитой

Реализованы вспомогательные механизмы:

- принятие cookie
- закрытие антибот-попапов
- автоматическая перезагрузка страницы при блокировке
- отключение загрузки ресурсов (изображения, шрифты, медиа)

## Управление данными

Результаты и служебные файлы структурированы по каталогам:

```
parser_app/
├── json/
│   ├── logs.json
│   ├── dataLogs/
│   └── baseClassLogs/
├── baseClass/
│   └── baseClassComment.json
└── exports/
    └── products_YYYY_MM_DD.xlsx
```

Поддерживается экспорт данных в Excel.

## Производительность

Используются стандартные оптимизации:

- блокировка ненужных ресурсов
- persistent browser context (куки, кеш)
- параллельный парсинг независимых блоков страницы

```javascript
const [productData, commentsData] = await Promise.all([
  productCard(browser, url),
  productComment(browser, url),
]);
```

## Electron-интерфейс

Приложение реализовано как полноценный desktop-клиент:

- кастомное управление окном
- preload-экран
- нативные диалоги
- IPC-взаимодействие между UI и backend-логикой

```javascript
ipcMain.handle("minimize-window", () => mainWindow.minimize());
ipcMain.handle("maximize-window", () =>
  mainWindow.isMaximized() ? mainWindow.unmaximize() : mainWindow.maximize()
);
```

## Конфигурация

Основные параметры парсинга вынесены в конфигурацию:

```javascript
const parsingConfig = {
  headless: false,
  timeout: 30000,
  waitUntil: "domcontentloaded",
  viewport: { width: 1920, height: 1080 },
  userAgent: "custom-agent",
  blockResources: ["image", "font", "media"],
};
```

## Обработка ошибок

При ошибках применяется поэтапное восстановление:

- попытка восстановить сессию
- переключение стратегии парсинга
- логирование контекста ошибки
- продолжение работы без полного падения приложения

## Назначение проекта

Проект не является универсальным коммерческим парсером.
Он служит:

- исследованием устойчивых подходов к парсингу динамических сайтов
- демонстрацией архитектурных решений
- примером сложного Electron + Playwright приложения
- основой для дальнейших экспериментов и расширений

Основной фокус — инженерные решения, наблюдаемость и отказоустойчивость, а не максимальная скорость или простота.
